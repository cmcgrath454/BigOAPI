<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: parse-code.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: parse-code.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { parse, BaseJavaCstVisitorWithDefaults } = require("java-parser");

/* Where class declaration ends and the user input begins */
const userInputStartIndex = 66;

/**
 * This function takes the source code and uses the parser to create
 * a syntax tree that is then turned into a statement tree 
 * @param {String} sourceCode 
 * @returns Tree of statement objects
 */
function parseCodeToTree(sourceCode) {
    const cst = parse(sourceCode);
    return buildStmtTree(cst);
}

/**
 * Builds statement tree by recursively going through the syntax
 * tree and pulling out the statements
 * @param {Object} cst concrete syntax tree generated by parser
 * @param {Object} parent parent node of tree in recursion
 * @returns a statement tree object
 */
function buildStmtTree(cst, parent = null) {
    const stmts = getStatements(cst);
    if (stmts.length == 0) return null;

    stmts.forEach((stmt, index) => {
        stmts[index]['parent'] = parent;
        stmts[index]['childStmts'] = [];

        const childStmt = stmt.hasOwnProperty('blockCst') ? buildStmtTree(stmt.blockCst, stmt) : null;

        if (stmt.hasOwnProperty('blockCst')) {
            buildStmtTree(stmt.blockCst, stmt);
            if (childStmt != null) stmts[index]['childStmts'].push(childStmt[0]);
        }
    })

    return stmts;
}

/**
 * Extends visitor method for statements, allows us to visit
 * each statement node in the concrete syntax tree and collect
 * the statements with their elements
 */
class StatementCollector extends BaseJavaCstVisitorWithDefaults {
    constructor() {
        super();
        this.blocks = [];
        this.validateVisitor();
    }

    statement(ctx) {
        for (const stmt in ctx) {
            if (stmt == 'statementWithoutTrailingSubstatement' || stmt == 'labeledStatement')
                this.visit(ctx[stmt]);
            else
                this.blocks.push(ctx[stmt]);
        }
    }
}


/**
 * Extends visitor method for for loops, allows us to visit
 * each for loop node in the concrete syntax tree and collect
 * the loops with their elements
 */
class ForLoopCollector extends BaseJavaCstVisitorWithDefaults {
    constructor() {
        super();
        this.loops = [];
        this.validateVisitor();
    }

    basicForStatement(ctx) {
        const forLoop = {
            type: 'forLoop',
            init: ctx.hasOwnProperty('forInit') ? getLeafNodes(ctx.forInit[0].children) : null,
            terminate: ctx.hasOwnProperty('expression') ? getLeafNodes(ctx.expression[0].children) : null,
            update: ctx.hasOwnProperty('forUpdate') ? getLeafNodes(ctx.forUpdate[0].children) : null,
            blockCst: ctx.hasOwnProperty('statement') ? ctx.statement[0] : null,
            location: {
                start: ctx.LBrace[0].startOffset - userInputStartIndex, end: ctx.RBrace[0].startOffset - userInputStartIndex
            }
        };
        this.loops.push(forLoop);
    }
}

/**
 * Extends visitor method for while loops, allows us to visit
 * each while loop node in the concrete syntax tree and collect
 * the loops with their elements
 */
class WhileLoopCollector extends BaseJavaCstVisitorWithDefaults {
    constructor() {
        super();
        this.loops = [];
        this.validateVisitor();
    }

    whileStatement(ctx) {
        const whileLoop = {
            type: 'whileLoop',
            terminate: ctx.hasOwnProperty('expression') ? getLeafNodes(ctx.expression[0].children) : null,
            blockCst: ctx.hasOwnProperty('statement') ? ctx.statement[0] : null,
            location: {
                start: ctx.expression[0].location.startOffset - userInputStartIndex, end: ctx.statement[0].location.endOffset - userInputStartIndex
            }
        };
        this.loops.push(whileLoop);
    }
}

/**
 * Goes through each statement to call the correct visitor
 * method to collect the elements of the statement
 * @param {Object} cst 
 * @returns statement objects with their elements for analysis
 */
function getStatements(cst) {
    let stmtCollector = new StatementCollector();
    stmtCollector.visit(cst);
    let stmts = [...stmtCollector.blocks];

    stmts.forEach((stmt, index) => {
        switch (stmt[0].name) {
            case 'forStatement':
                stmts[index] = getForLoops(stmt);
                break;
            case 'whileStatement':
                stmts[index] = getWhileLoops(stmt);
                break;
            default:
                getStatements(stmts);
        }
    })
    return stmts;
}

/**
 * Uses for loop visitor method to collect the for loop within
 * a statement
 * @param {*} cst syntax tree object
 * @returns the for loop collected with its elements
 */
function getForLoops(cst) {
    let forLoopCollector = new ForLoopCollector();
    forLoopCollector.visit(cst);
    return forLoopCollector.loops[0];
}

/**
 * Uses while loop visitor method to collect the while loop within
 * a statement
 * @param {*} cst syntax tree object
 * @returns the while loop collected with its elements
 */
function getWhileLoops(cst) {
    let whileLoopCollector = new WhileLoopCollector();
    whileLoopCollector.visit(cst);
    return whileLoopCollector.loops[0];
}

/**
 * Takes a tree node and drills down to their leaf nodes
 * which represent the actual syntax used in the code
 * @param {Object} ctx concrete tree node
 * @returns An array of leaf nodes
 */
function getLeafNodes(ctx) {
    const nodes = [];
    recursiveGetLeafNodes(ctx, nodes);
    return nodes;
}

/**
 * The recursive function called to get the leaf nodes
 * from getLeafNodes(ctx)
 * @param {*} ctx concrete tree node
 * @param {*} arr array of leaf nodes
 */
function recursiveGetLeafNodes(ctx, arr) {
    const props = Object.getOwnPropertyNames(ctx);
    props.forEach(prop => {
        ctx[prop].forEach(elem => {
            const childCtx = elem.children;
            if (childCtx != null) {
                recursiveGetLeafNodes(childCtx, arr);
            } else {
                arr.push({
                    [prop]: elem.image
                });
            }
        });
    })
}

exports.parseCodeToTree = parseCodeToTree;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ForLoopCollector.html">ForLoopCollector</a></li><li><a href="StatementCollector.html">StatementCollector</a></li><li><a href="WhileLoopCollector.html">WhileLoopCollector</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addStmtBigO">addStmtBigO</a></li><li><a href="global.html#analyzeBigO">analyzeBigO</a></li><li><a href="global.html#buildStmtTree">buildStmtTree</a></li><li><a href="global.html#findLargestBigO">findLargestBigO</a></li><li><a href="global.html#forLoopIsSupported">forLoopIsSupported</a></li><li><a href="global.html#getForLoopBigO">getForLoopBigO</a></li><li><a href="global.html#getForLoops">getForLoops</a></li><li><a href="global.html#getLeafNodes">getLeafNodes</a></li><li><a href="global.html#getSourceCodeBigO">getSourceCodeBigO</a></li><li><a href="global.html#getStatements">getStatements</a></li><li><a href="global.html#getWhileLoopBigO">getWhileLoopBigO</a></li><li><a href="global.html#getWhileLoops">getWhileLoops</a></li><li><a href="global.html#handler">handler</a></li><li><a href="global.html#mapTree">mapTree</a></li><li><a href="global.html#parseCodeToTree">parseCodeToTree</a></li><li><a href="global.html#recursiveGetLeafNodes">recursiveGetLeafNodes</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.0</a> on Sat Dec 10 2022 22:42:30 GMT-0600 (Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
