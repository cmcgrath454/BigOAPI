const { parse, BaseJavaCstVisitorWithDefaults } = require("java-parser");

/* Where class declaration ends and the user input begins */
const userInputStartIndex = 66;

/**
 * This function takes the source code and uses the parser to create
 * a syntax tree that is then turned into a statement tree 
 * @param {String} sourceCode 
 * @returns Tree of statement objects
 */
function parseCodeToTree(sourceCode) {
    const cst = parse(sourceCode);
    return buildStmtTree(cst);
}

/**
 * Builds statement tree by recursively going through the syntax
 * tree and pulling out the statements
 * @param {Object} cst concrete syntax tree generated by parser
 * @param {Object} parent parent node of tree in recursion
 * @returns a statement tree object
 */
function buildStmtTree(cst, parent = null) {
    const stmts = getStatements(cst);
    if (stmts.length == 0) return null;

    stmts.forEach((stmt, index) => {
        stmts[index]['parent'] = parent;
        stmts[index]['childStmts'] = [];

        const childStmt = stmt.hasOwnProperty('blockCst') ? buildStmtTree(stmt.blockCst, stmt) : null;

        if (stmt.hasOwnProperty('blockCst')) {
            buildStmtTree(stmt.blockCst, stmt);
            if (childStmt != null) stmts[index]['childStmts'].push(childStmt[0]);
        }
    })

    return stmts;
}

/**
 * Extends visitor method for statements, allows us to visit
 * each statement node in the concrete syntax tree and collect
 * the statements with their elements
 */
class StatementCollector extends BaseJavaCstVisitorWithDefaults {
    constructor() {
        super();
        this.blocks = [];
        this.validateVisitor();
    }

    statement(ctx) {
        for (const stmt in ctx) {
            if (stmt == 'statementWithoutTrailingSubstatement' || stmt == 'labeledStatement')
                this.visit(ctx[stmt]);
            else
                this.blocks.push(ctx[stmt]);
        }
    }
}


/**
 * Extends visitor method for for loops, allows us to visit
 * each for loop node in the concrete syntax tree and collect
 * the loops with their elements
 */
class ForLoopCollector extends BaseJavaCstVisitorWithDefaults {
    constructor() {
        super();
        this.loops = [];
        this.validateVisitor();
    }

    basicForStatement(ctx) {
        const forLoop = {
            type: 'forLoop',
            init: ctx.hasOwnProperty('forInit') ? getLeafNodes(ctx.forInit[0].children) : null,
            terminate: ctx.hasOwnProperty('expression') ? getLeafNodes(ctx.expression[0].children) : null,
            update: ctx.hasOwnProperty('forUpdate') ? getLeafNodes(ctx.forUpdate[0].children) : null,
            blockCst: ctx.hasOwnProperty('statement') ? ctx.statement[0] : null,
            location: {
                start: ctx.For[0].startOffset - userInputStartIndex, end: ctx.RBrace[0].startOffset - userInputStartIndex
            }
        };
        this.loops.push(forLoop);
    }
}

/**
 * Extends visitor method for while loops, allows us to visit
 * each while loop node in the concrete syntax tree and collect
 * the loops with their elements
 */
class WhileLoopCollector extends BaseJavaCstVisitorWithDefaults {
    constructor() {
        super();
        this.loops = [];
        this.validateVisitor();
    }

    whileStatement(ctx) {
        const whileLoop = {
            type: 'whileLoop',
            terminate: ctx.hasOwnProperty('expression') ? getLeafNodes(ctx.expression[0].children) : null,
            blockCst: ctx.hasOwnProperty('statement') ? ctx.statement[0] : null,
            location: {
                start: ctx.While[0].startOffset - userInputStartIndex, end: ctx.RBrace[0].startOffset - userInputStartIndex
            }
        };
        this.loops.push(whileLoop);
    }
}

/**
 * Goes through each statement to call the correct visitor
 * method to collect the elements of the statement
 * @param {Object} cst 
 * @returns statement objects with their elements for analysis
 */
function getStatements(cst) {
    let stmtCollector = new StatementCollector();
    stmtCollector.visit(cst);
    let stmts = [...stmtCollector.blocks];

    stmts.forEach((stmt, index) => {
        switch (stmt[0].name) {
            case 'forStatement':
                stmts[index] = getForLoops(stmt);
                break;
            case 'whileStatement':
                stmts[index] = getWhileLoops(stmt);
                break;
            default:
                getStatements(stmts);
        }
    })
    return stmts;
}

/**
 * Uses for loop visitor method to collect the for loop within
 * a statement
 * @param {*} cst syntax tree object
 * @returns the for loop collected with its elements
 */
function getForLoops(cst) {
    let forLoopCollector = new ForLoopCollector();
    forLoopCollector.visit(cst);
    return forLoopCollector.loops[0];
}

/**
 * Uses while loop visitor method to collect the while loop within
 * a statement
 * @param {*} cst syntax tree object
 * @returns the while loop collected with its elements
 */
function getWhileLoops(cst) {
    let whileLoopCollector = new WhileLoopCollector();
    whileLoopCollector.visit(cst);
    return whileLoopCollector.loops[0];
}

/**
 * Takes a tree node and drills down to their leaf nodes
 * which represent the actual syntax used in the code
 * @param {Object} ctx concrete tree node
 * @returns An array of leaf nodes
 */
function getLeafNodes(ctx) {
    const nodes = [];
    recursiveGetLeafNodes(ctx, nodes);
    return nodes;
}

/**
 * The recursive function called to get the leaf nodes
 * from getLeafNodes(ctx)
 * @param {*} ctx concrete tree node
 * @param {*} arr array of leaf nodes
 */
function recursiveGetLeafNodes(ctx, arr) {
    const props = Object.getOwnPropertyNames(ctx);
    props.forEach(prop => {
        ctx[prop].forEach(elem => {
            const childCtx = elem.children;
            if (childCtx != null) {
                recursiveGetLeafNodes(childCtx, arr);
            } else {
                arr.push({
                    [prop]: elem.image
                });
            }
        });
    })
}

exports.parseCodeToTree = parseCodeToTree;